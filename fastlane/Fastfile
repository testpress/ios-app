# ios-app/fastlane/Fastfile
# --------------------------------------------------------------
#  ONE-LANE DEPLOYMENT for iOS â€“ fully driven by config.json
# --------------------------------------------------------------

require 'fileutils'
require 'mini_magick'
require 'json'
require 'xcodeproj'
require 'fastlane_core/ui/ui'

$config = {}
default_platform(:ios)

# -----------------------------------------------------------------
#  Global constants (relative to Fastfile location)
# -----------------------------------------------------------------
ASSETS_DIR          = "../ios-app/Assets.xcassets".freeze
PROJECT_PATH        = "../ios-app.xcodeproj".freeze
INFO_PLIST_PATH     = "../ios-app/Info.plist".freeze
APP_CONSTANTS_PATH  = "../ios-app/Utils/AppConstants.swift".freeze
ICON_SOURCE         = "fastlane/Icon-1024.png".freeze
LAUNCH_SOURCE       = "fastlane/LaunchImage.png".freeze

# -----------------------------------------------------------------
#  Helper: PlistBuddy safe set / add
# -----------------------------------------------------------------
def plist_set_or_add(plist_path, key_path, value)
  value_escaped = value.to_s.gsub("'", "\\\\'")
  set_cmd = "/usr/libexec/PlistBuddy -c \"Set :#{key_path} #{value_escaped}\" '#{plist_path}'"
  add_cmd = "/usr/libexec/PlistBuddy -c \"Add :#{key_path} string #{value_escaped}\" '#{plist_path}'"

  sh(set_cmd)
rescue
  UI.message("Key :#{key_path} missing â€“ adding it")
  sh(add_cmd)
rescue => e
  UI.user_error!("PlistBuddy failed: #{e.message}")
end

# -----------------------------------------------------------------
#  Helper: Resize + write (centralised)
# -----------------------------------------------------------------
def resize_and_save(source, dest, width:, height:, resize_mode: "", background: $config["image_background"])
  UI.user_error!("Source missing: #{source}") unless File.exist?(source)

  FileUtils.mkdir_p(File.dirname(dest))
  image = MiniMagick::Image.open(source)
  image.combine_options do |c|
    c.resize "#{width}x#{height}#{resize_mode}"
    c.gravity "center"
    c.background background
    c.extent "#{width}x#{height}"
  end
  image.write(dest)
  UI.message("Generated #{File.basename(dest)} (#{width}Ã—#{height})")
end

# -----------------------------------------------------------------
#  Helper: Load the main app target
# -----------------------------------------------------------------
def app_target
  UI.user_error!("Project not found: #{PROJECT_PATH}") unless File.exist?(PROJECT_PATH)
  project = Xcodeproj::Project.open(PROJECT_PATH)
  target = project.targets.find { |t| t.product_type == "com.apple.product-type.application" }
  UI.user_error!("No app target found") unless target
  target
end

# -----------------------------------------------------------------
#  ACTION: Generate App Icons (uses Contents.json)
# -----------------------------------------------------------------
desc "Generate all AppIcon sizes from Icon-1024.png"
lane :generate_app_icons do
  appiconset   = File.join(ASSETS_DIR, "AppIcon.appiconset")
  contents_path = File.join(appiconset, "Contents.json")
  UI.user_error!("Missing Icon-1024.png") unless File.exist?(ICON_SOURCE)
  UI.user_error!("Missing Contents.json") unless File.exist?(contents_path)

  contents = JSON.parse(File.read(contents_path))
  contents["images"].each do |img|
    next unless (filename = img["filename"])
    size_str = img["size"]
    scale    = img["scale"][/(\d)x/, 1].to_i
    scale    = 1 if scale.zero?
    pixels   = (size_str.split("x").first.to_f * scale).round
    dest     = File.join(appiconset, filename)

    resize_and_save(
      ICON_SOURCE,
      dest,
      width: pixels,
      height: pixels,
      resize_mode: "",          # square â€“ no caret
      background: "transparent"
    )
  end
  UI.success("All App Icons generated")
end

# -----------------------------------------------------------------
#  ACTION: Login screen image (1Ã—)
# -----------------------------------------------------------------
desc "Generate login_screen_image.png (646Ã—218)"
lane :generate_login_image do
  imageset = File.join(ASSETS_DIR, "login_screen_image.imageset")
  dest = File.join(imageset, "login_screen_image.png")
  resize_and_save(LAUNCH_SOURCE, dest, width: 646, height: 218, background: $config["image_background"])
  UI.success("Login image generated")
end

# -----------------------------------------------------------------
#  ACTION: All launch images (hard-coded list)
# -----------------------------------------------------------------
desc "Generate every launch image from LaunchImage.png"
lane :generate_launch_images do
  output_dir = File.join(ASSETS_DIR, "LaunchImage.launchimage")
  FileUtils.mkdir_p(output_dir)

  launch_images = [
    ["LaunchImage-1242@3x~iphoneXsMax-portrait_1242x2688.png", 1242, 2688],
    ["LaunchImage-2688@3x~iphoneXsMax-landscape_2688x1242.png", 2688, 1242],
    ["LaunchImage-828@2x~iphoneXr-portrait_828x1792.png", 828, 1792],
    ["LaunchImage-1792@2x~iphoneXr-landscape_1792x828.png", 1792, 828],
    ["LaunchImage-1125@3x~iphoneX-portrait_1125x2436.png", 1125, 2436],
    ["LaunchImage-2436@3x~iphoneX-landscape_2436x1125.png", 2436, 1125],
    ["splash_screen_1242x2208.png", 1242, 2208],
    ["LaunchImage-1242@3x~iphone6s-landscape_2208x1242.png", 2208, 1242],
    ["splash_screen_1.png", 750, 1334],
    ["splash_screen_640x960.png", 640, 960],
    ["splash_screen_640x1136_2.png", 640, 1136],
    ["splash_screen_768x1024.png", 768, 1024],
    ["splash_screen_1024x768.png", 1024, 768],
    ["splash_screen_4.png", 1536, 2048],
    ["splash_screen_2.png", 2048, 1536]
  ]

  launch_images.each do |filename, w, h|
    resize_and_save(LAUNCH_SOURCE, File.join(output_dir, filename), width: w, height: h)
  end
  UI.success("All launch images generated")
end

# -----------------------------------------------------------------
#  ACTION: Update AppConstants.swift from options
# -----------------------------------------------------------------
desc "Patch AppConstants.swift with values from config"
private_lane :update_app_constants do |options|
  UI.user_error!("AppConstants.swift missing") unless File.exist?(APP_CONSTANTS_PATH)

  content = File.read(APP_CONSTANTS_PATH)

  {
    subdomain:      "SUBDOMAIN",
    app_apple_id:   "APP_APPLE_ID",
    primary_color:  "PRIMARY_COLOR",

  }.each do |opt_key, const|
    next unless (value = options[opt_key])
    regex = /public static let #{const} = ".*?"/
    new_line = "public static let #{const} = \"#{value}\""
    content.gsub!(regex, new_line)
    UI.message("Updated #{const} = \"#{value}\"")
  end

  File.write(APP_CONSTANTS_PATH, content)
  UI.success("AppConstants.swift updated")
end

# -----------------------------------------------------------------
#  ACTION: Copy GoogleService-Info.plist
# -----------------------------------------------------------------
desc "Replace GoogleService-Info.plist with the one from config"
private_lane :update_google_plist do |options|
  source = options[:source] || UI.user_error!(":source required")
  target = "../ios-app/GoogleService-Info.plist"

  UI.user_error!("Source plist missing: #{source}") unless File.exist?(source)

  FileUtils.rm_f(target)
  FileUtils.cp(source, target)
  UI.success("GoogleService-Info.plist replaced")
end

# -----------------------------------------------------------------
#  ACTION: Disable Zoom (comment code)
# -----------------------------------------------------------------
desc "Comment out Zoom-related Swift files"
lane  :disable_zoom_code do
  # 1. ZoomMeetViewController.swift
  zoom_file = "../CourseKit/Source/UI/ViewControllers/ZoomMeetViewController.swift"
  if File.exist?(zoom_file)
    File.write(zoom_file, "/*\n#{File.read(zoom_file)}\n*/")
    UI.message("Commented ZoomMeetViewController.swift")
  else
    UI.message(zoom_file)
    UI.message("ZoomMeetViewController.swift not present")
  end

  # 2. openZoomMeeting() body in VideoConferenceViewController.swift
  vc_file = "../CourseKit/Source/UI/ViewControllers/VideoConferenceViewController.swift"
  next unless File.exist?(vc_file)

  lines = File.readlines(vc_file)
  out   = []
  inside = false
  level  = 0

  lines.each do |line|
    if !inside && line.match(/func\s+openZoomMeeting\s*\(/)
      inside = true
      level  = 1
      out << line
      next
    end

    if inside
      level += line.count('{')
      level -= line.count('}')
      out << (level > 0 ? "// #{line}" : line)
      inside = false if level <= 0
    else
      out << line
    end
  end

  File.write(vc_file, out.join)
  UI.message("Commented openZoomMeeting() body")
end

# -----------------------------------------------------------------
#  ACTION: Strip Zoom frameworks / resources from Xcode project
# -----------------------------------------------------------------
desc "Remove Zoom xcframework & bundle from the Xcode project"
lane :remove_zoom_module do
  project = Xcodeproj::Project.open(PROJECT_PATH)
  target = project.targets.find { |t| t.product_type == "com.apple.product-type.application" }

  UI.user_error!("No app target found") unless target

  # Frameworks (Link Binary)
  %w[MobileRTC.xcframework].each do |fw|
    ref = target.frameworks_build_phase.files.find { |f| f.display_name.include?(fw) }
    if ref
      target.frameworks_build_phase.remove_file_reference(ref.file_ref)
      UI.message("Removed #{fw} from Link Binary")
    end
  end

  # Embed Frameworks phase
  target.copy_files_build_phases.each do |phase|
    next unless phase.name&.downcase&.include?("embed")

    %w[MobileRTC.xcframework].each do |fw|
      ref = phase.files.find { |f| f.display_name.include?(fw) }
      if ref
        phase.remove_file_reference(ref.file_ref)
        UI.message("Removed #{fw} from Embed Frameworks")
      end
    end
  end

  # Resources
  %w[MobileRTCResources.bundle].each do |res|
    ref = target.resources_build_phase.files.find { |f| f.display_name.include?(res) }
    if ref
      target.resources_build_phase.remove_file_reference(ref.file_ref)
      UI.message("Removed #{res} from Resources")
    end
  end

  # SAVE THE SAME INSTANCE
  project.save
  UI.success("Zoom module stripped from Xcode project")
end
# -----------------------------------------------------------------
#  ACTION: Update bundle ID + display name
# -----------------------------------------------------------------
desc "Set bundle identifier & display name (project + plist)"
private_lane :update_app_identity do |options|
  bundle_id    = options[:bundle_identifier] || UI.user_error!("bundle_identifier required")
  display_name = options[:display_name]     || UI.user_error!("display_name required")

<<<<<<< HEAD
  UI.message("Updating identity â†’ #{bundle_id} / #{display_name}")

  # âœ… Open project once
  project = Xcodeproj::Project.open(PROJECT_PATH)
  target = project.targets.find { |t| t.product_type == "com.apple.product-type.application" }

  UI.user_error!("No app target found in #{PROJECT_PATH}") unless target

  # âœ… Update all configurations (Debug/Release)
  target.build_configurations.each do |cfg|
    old_id = cfg.build_settings["PRODUCT_BUNDLE_IDENTIFIER"]
    cfg.build_settings["PRODUCT_BUNDLE_IDENTIFIER"] = bundle_id
    cfg.build_settings["PRODUCT_NAME"] = display_name
    cfg.build_settings["INFOPLIST_KEY_CFBundleDisplayName"] = display_name
    UI.message("#{cfg.name}: #{old_id} â†’ #{bundle_id}")
=======
lane :update_bundle_display_name do |options|
  require 'fastlane_core/ui/ui'

  # Ensure a display name is provided
  unless options[:display_name] && !options[:display_name].empty?
    UI.user_error!("âŒ Please provide a display_name, e.g., display_name: 'Qaaf Academy'")
  end

  plist_path = "../ios-app/Info.plist"
  unless File.exist?(plist_path)
    UI.user_error!("âŒ Info.plist not found at #{plist_path}")
  end

  display_name = options[:display_name]

  # Check if CFBundleDisplayName exists
  begin
    existing_value = sh("/usr/libexec/PlistBuddy -c \"Print :CFBundleDisplayName\" '#{plist_path}'", error_callback: ->(_) { nil })
  rescue
    existing_value = nil
  end

  if existing_value.nil? || existing_value.empty?
    UI.message("â„¹ï¸ CFBundleDisplayName not found â€” adding new key.")
    sh("/usr/libexec/PlistBuddy -c \"Add :CFBundleDisplayName string '#{display_name}'\" '#{plist_path}'")
  else
    UI.message("ðŸ”¹ Updating existing CFBundleDisplayName (#{existing_value.strip} â†’ #{display_name})")
    sh("/usr/libexec/PlistBuddy -c \"Set :CFBundleDisplayName '#{display_name}'\" '#{plist_path}'")
  end

  UI.success("âœ… CFBundleDisplayName updated to '#{display_name}' in Info.plist")
end

lane :update_app_identity do |options|
  require 'xcodeproj'
  require 'fastlane_core/ui/ui'

  bundle_id = options[:bundle_identifier]
  display_name = options[:display_name]

  if bundle_id.nil? || display_name.nil?
    UI.user_error!("âŒ Missing parameters: bundle_identifier or display_name")
  end

  UI.message("ðŸš€ Updating app identity...")
  UI.message("   â€¢ Bundle Identifier â†’ #{bundle_id}")
  UI.message("   â€¢ Display Name â†’ #{display_name}")

  # --- Update Bundle Identifier ---
  project_path = "../ios-app.xcodeproj"
  unless File.exist?(project_path)
    UI.user_error!("âŒ Xcode project not found at #{project_path}")
  end

  project = Xcodeproj::Project.open(project_path)
  app_target = project.targets.find { |t| t.product_type == "com.apple.product-type.application" }

  unless app_target
    UI.user_error!("âŒ No application target found in project!")
  end

  app_target.build_configurations.each do |config|
    old_id = config.build_settings["PRODUCT_BUNDLE_IDENTIFIER"]
    config.build_settings["PRODUCT_BUNDLE_IDENTIFIER"] = bundle_id
    UI.message("âœ… Updated #{config.name} bundle ID: #{old_id} â†’ #{bundle_id}")
>>>>>>> 4e296765 (Manjoorans first release)
  end

  # âœ… Save the same project instance
  project.save

  # âœ… Also patch Info.plist (Xcode uses both)
  plist_set_or_add(INFO_PLIST_PATH, "CFBundleIdentifier", bundle_id)
  plist_set_or_add(INFO_PLIST_PATH, "CFBundleDisplayName", display_name)

  UI.success("âœ… Identity updated successfully â†’ #{bundle_id}")
end

# -----------------------------------------------------------------
#  MAIN LANE: Deploy (single entry point)
# -----------------------------------------------------------------
desc "Full iOS re-brand / asset generation pipeline"
lane :deploy do |options|
  # -----------------------------------------------------------------
  # 1. Load & validate config.json
  # -----------------------------------------------------------------
  config_path = options[:config] || "config.json"
  $config = JSON.parse(File.read(config_path))

  UI.user_error!("config.json not found: #{config_path}") unless File.exist?(config_path)

  config = JSON.parse(File.read(config_path))

  required = %w[subdomain apple_id primary_color google_plist_path display_name bundle_identifier]
  missing = required.select { |k| config[k].to_s.empty? }
  UI.user_error!("Missing config fields: #{missing.join(', ')}") unless missing.empty?

  zoom_enabled = config.dig("features", "zoom_enabled") == true

  # -----------------------------------------------------------------
  # 2. Asset generation (parallel when requested)
  # -----------------------------------------------------------------
  asset_lanes = %i[generate_app_icons generate_login_image generate_launch_images]
  if options[:parallel]
    UI.message("Running asset lanes in parallel")
    asset_lanes.each { |l| lane_thread(l) }
    wait_for_threads
  else
    asset_lanes.each { |l| send(l) }
  end

  # -----------------------------------------------------------------
  # 3. AppConstants.swift
  # -----------------------------------------------------------------
  update_app_constants(
    subdomain:      config["subdomain"],
    app_apple_id:   config["apple_id"],
    primary_color:  config["primary_color"]
  )

  # -----------------------------------------------------------------
  # 4. GoogleService-Info.plist
  # -----------------------------------------------------------------
  update_google_plist(source: config["google_plist_path"])

  # -----------------------------------------------------------------
  # 5. Zoom handling
  # -----------------------------------------------------------------
  if zoom_enabled
    UI.success("Zoom feature kept enabled")
  else
    disable_zoom_code
    remove_zoom_module
  end

  # -----------------------------------------------------------------
  # 6. Identity
  # -----------------------------------------------------------------
  update_app_identity(
    bundle_identifier: config["bundle_identifier"],
    display_name:      config["display_name"]
  )

  # -----------------------------------------------------------------
  # 7. Final summary
  # -----------------------------------------------------------------
  UI.header("Deployment complete")
  UI.message("Subdomain: #{config['subdomain']}")
  UI.message("Bundle ID: #{config['bundle_identifier']}")
  UI.message("Display name: #{config['display_name']}")
  UI.message("Zoom: #{zoom_enabled ? 'ENABLED' : 'DISABLED'}")
end
